# **Java**

## jdk install 
sudo apt install openjdk-8-jdk

## Type
### **Enum** 
    列挙型で自身で内部的にインスタンス化して呼出可能な状態になる insight/column_128) [Link](https://www.modis.co.jp/candidate/)</br>
    format: アクセス修飾子 enum 列挙名 {列挙子1, 列挙子2, ・・・}


## **EJB**
ソフトウェア部品を組み合わせて開発できるようにしたもの  
インテターフェースの名前対応表  
https://itpfdoc.hitachi.co.jp/manuals/3020/30203M0360/EM030192.HTM


![Java Data Object](https://github.com/s18013/Memo/blob/main/img/java_data_object.png "Title")


## **Class**
- 特定の機能をまとめた塊</br>
- ファイル名と一致している必要がある</br>
- この中に含まれる要素(メソッドなど)をメンバーと呼ぶ

## **Method**
- 機能を表すもの<br>
- mainは特別なメソッドでアプリ起動した時探し出されて実行される
エントリーポイントとも呼ばれる<br>
- {}(ブロック)で囲われている


## **繰り返し**

### **インクリメント演算子/デクリメント演算子**
- "++" インクリメント
- "--" デクリメント
```
var i = 3;
var j = ++i; -> iに1加算した後に代入
var j = i++; -> iに1加算する前に代入
```

## **演算子**
- a = b + cとなる時、"=","+"のことを演算子、それ以外の変数を非演算子(オペランド)という

|    |    |
|----|----|
|==|値の同一性を比較する|
|?:|条件式 ? Trueの時 : Falseの時</br> オペランドが３つ必要なことから三項演算子ともいう|


##  **アクセス修飾子**

### **protected**
- 同一パッケージ内もしくは、違うパッケージでも継承関係ならアクセスOKとなる

### **final**
- 再代入できない様にできる

```
以下のケースについては、参照型(list)をfinalで定義しているため
参照先のデータについては変更できてしまう

final int[] VALUE = {10, 20, 30}
VALUE = new int[] {10, 30, 50} --> 変更できない(参照先を変更しようとしてるため)
int[0] = 50 --> 変更できる(参照先のデータを変更しようとしてるため)


上記のケースが仮にStringだった場合は、変更できない(Stringは不変系)
なのでString＋finalで完全に変更できない値が作れる
```



## **データ型**
|整数 |    |    |
|----|----|----|
|byte|1byte||
|short|2byte||
|int|4byte|特別な理由がない場合はこれ使う|
|long|8byte||

備考 : </br>
- "_"で桁を区切って読み易くすることが出来る
- intの値をlongに格納すると暗黙的な型変換(拡大変換)で格納することができる
- intからbyteへの縮小変換については、"(byte)"を変数名の前につけて行う明示的変換でのみ可能


|浮動小数点 |    |    |
|----|----|----|
|floot|4byte||
|double|8byte|特別な理由がない限りはこれ使う|

備考 : </br>
浮動少数点は、以下のように表現されている</br>
12.5(10進数)</br>
= 1100.1000(2進数) </br>
= 1.1001000 * 2^3</br>
上記を以下の様に格納することで表現されている</br>
[1(符号"-")] [10000010(指数 3 + 127)] [100100(仮数 1は固定なので省略)]</br>
欠点として指数部の値が大きい時に値が飛び幅が大きくなる</br>
例　12.5 * 10^10 ~ 12.6 * 10^10 よりも　12.5 * 10^100 ~ 12.6 * 10^100の飛び幅はでかい

|真偽 |    |    |
|----|----|----|
|boolean|1bit|デフォルト値 : false|

|文字 |    |    |
|----|----|----|
|char|2bit|デフォルト値 : \u0000(null)</br>文字列ではなく文字を格納するイメージ|

### **var**
- 型推論で自動的に型そ設定してくれる
- メソッド内の変数としてのみ定義可能(フィールド宣言できない)
- 必ず初期値を設定する必要がある
- 型を明示的にする必要がない場合は積極的に使う

### **null**
オブジェクトへの参照を持たない状態の変数の事</br>
アクセスしようとするとNullPointerExceptionが発動する</br>
オブジェクトが存在しない場合を明示的に示したい場合や、</br>
オブジェクトを破棄したい場合に、限定して使用する</br>
Optionalを併用して使うとより安全

### **配列**
生成は以下の様に行う。
```
int[] list = new int[5] 長さのみ指定パターン
int[] list = new int[]{1, 2, 3, 4, 5} 初期値を入れとくパターン
int list[] = {1, 2, 3} C言語の名残パターン

アクセスは以下
int[2]
-> 3が返される
```
インデックスに要素を超える数を設定すると、ArrayIndexOutOfBoundsException例外が発生</br>
new して作成していることからStringのようにクラスがある様に見えるが、</br>
そうではなくあくまで言語に組み込まれた擬似的なクラス</br>
特殊な配列として**ジャグ配列**という2次元目の要素数が異なる配列も定義可能
```
var list = new int[3][];
list[0] = new int[2]
list[1] = new int[5]
list[2] = new int[6]
```

## **組み込み**

### **StringBuilder**
- "+"で結合す結合すると結合元、結合先、結合されたものの３つ作成される(効率が良くない)
  ->新しいjavaでは＋の際にStringuBuilderが呼ばれて同じの性能が出る
- こいつの場合はあらかじめ確保した領域で行なっている
- 似たものとしてStringBufferがあるがこちらは、String Builderの排他的制御版(遅い)
```
var builder = new StringBuilder(1000) -> あらかじめサイズを決めておける
```

### **BigDecimal**
- 以下の様な小数点以下で起こる誤差を解消してくれるもの
- 誤差を生じさせないために、引数は文字で指定するように
```
Math.floor((0.1 + 0.7) * 10)
-> 0.7
内部的に0.1は２進数で表すと無限循環小数になっているため
7.999999の様になっており上記の様な結果が返ってきていしまう
```



## **用語集**

### **完全修飾名**
クラスを識別する際に、「パッケージ＋クラス名」で識別する。</br>
以下のようなフルで書いた状態のこと</br>
java.time.LocalDateTime</br>
上記の様な状態を解決するために、importする(名前解決という)</br>
名前解決後のクラス名だけの状態を単純名という

### **静的型付け**
変数を宣言する際に設定した型以外の値が代入することが出来ないこと
型をプログラマが明示的に設定する必要がある

### **動的型付け**
変数を宣言する際に型を明示的に設定しなくても予測して設定してくれること

### **基本型**
数値や文字そのものが入っている変数のこと</br>
プリミティブ型と呼ばれる事もある(構造がシンプルで原始的)
int, charなど

### **参照型**
数値や文字が格納されている場所を持っている変数のこと
list, objなど

### **データソース**
DBに接続する際に必要な情報(ホスト名など)をまとめたもの</br>
DNS(固有の識別名)で識別される

### **リテラル**
値を格納できる値、また、値の表現方法</br>
例 2進数(0b0100),16進数(0xff),文字('')、文字列("")

### **型サレフィックス**
末尾につけてデータ型を指定できるもの</br>
long: L,l </br>
float: F,f </br>
double: D,d</br>

### **インスタンス/オブジェクト**
クラスをnewした物</br>
クラス内のフィールドはコピーされ、メソッドはクラスでの定義を参照

### **フィールド**
クラス内で用意されているデータの入れ物

### **クラスフィールド/クラスメソッド**
オブジェクトを生成せずともクラスから直接呼び出せる(静的フィールド/静的メソッドとも言う)</br>
反対にオブジェクトの生成が必要なものを、**インスタンスフィールド/インスタンスメソッド**という

### **同一性/同値性**
- 同一性は値が同一のものかどうか、javaにおいては"=="で比較される(基本型はこれで比較しても値の比較が行われる)
- 同値性は値が同じ値かどうか、javaにおいては"equals"メソッドで比較する(参照型はこれを使えば値の比較が行われる)
```
例
String stringA = new StringBuilder("ABC").toString();
String stringB = new StringBuilder("ABC").toString();

stringA == stringB
-> false
上記については、stringAとstringBで別の番地のメモリに格納された
別物なのでfalse判定

stringA.equals(stringB)
-> true
この場合は値が同じかどうか(同値性)を見ているためtrue判定

```

# Eclipse

## Shortcut
|    |    |
|----|----|
|Ctr + Space|ソースの補完|
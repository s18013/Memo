# **Java**

## jdk install 
sudo apt install openjdk-8-jdk

## Type
### **Enum** 
    列挙型で自身で内部的にインスタンス化して呼出可能な状態になる insight/column_128) [Link](https://www.modis.co.jp/candidate/)</br>
    format: アクセス修飾子 enum 列挙名 {列挙子1, 列挙子2, ・・・}


## **EJB**
ソフトウェア部品を組み合わせて開発できるようにしたもの  
インテターフェースの名前対応表  
https://itpfdoc.hitachi.co.jp/manuals/3020/30203M0360/EM030192.HTM


![Java Data Object](https://github.com/s18013/Memo/blob/main/img/java_data_object.png "Title")


## **Class**
- 特定の機能をまとめた塊</br>
- ファイル名と一致している必要がある</br>
- この中に含まれる要素(メソッドなど)をメンバーと呼ぶ

## **Method**
- 機能を表すもの<br>
- mainは特別なメソッドでアプリ起動した時探し出されて実行される
エントリーポイントとも呼ばれる<br>
- {}(ブロック)で囲われている

## **条件分岐**
- 条件に一致した最初のブロックのみ実行されるため、条件は範囲の狭い順でかく
- if分でelseのみ採用したい場合は、ifブロックに";"を記入する(";"は空を意味する)

### **switch**
- 以下の様な複数のケースをbreakしないまま処理することを**フォールスルー**という
  また以下の様な特殊なケースを除く場合は、フォールスルーを起こすべきでない
```
var val = "A"

switch(val) {
    case "A":
    case "B":
      System.out.println("XX");
      break;
    case "c":
      break;

}
```

## **繰り返し**
### **インクリメント演算子/デクリメント演算子**
- "++" インクリメント
- "--" デクリメント
```
var i = 3;
var j = ++i; -> iに1加算した後に代入
var j = i++; -> iに1加算する前に代入
```

### **for**
```
first:
for (int i = 0(初期化式); i < 6(継続条件式); i++(増減式)) {
    for(int j =0; i< 6; i++){
        break first; -> 単にbreakだけだとネストしたルーブの内側までしか抜け出せないため
                        外側のループにラベルをつけてやる必要がある
    }
}

拡張for
for (var value(仮変数): data(配列/コレクション)) {...}

```
<注意点>
- ループ内のオブジェクト生成はガベージコレクション頻発でオーバーヘッドになるため注意
- 例外処理などはそもそもオーバーヘッドがかかるものはループ内で処理しない
- for内で使用されているカウント関数はforがいからの参照不可
- 以下の様な外部の変数をカウンター変数として採用した場合</br>
  for文が外部の変数を参照できる様になってしまうので避ける
- カウンター変数に浮遊点小数を採用しない(インクリメントがうまくいかないため)

```
悪い例
double i;
for (i = 1; i < 6; i++) {...}
```


## **比較**
- a = b + cとなる時、"=","+"のことを演算子、それ以外の変数を非演算子(オペランド)という
- ショートカット演算子、"&&","||"の様に"&","|"を二つ並べることで左辺の変数が</br>
  条件を満たしていた場合右辺をスキップする</br>
  ```
  例　value != null && check(value)
    -> こうすることでvalueがnullだった場合右辺の計算が行われないためぬるぽ対策にもなる
  ```
   

|    |    |
|----|----|
|==|値の同一性を比較する(基本型の場合は同値比較)|
|?:|条件演算子、条件式 ? Trueの時 : Falseの時</br> オペランドが３つ必要なことから三項演算子ともいう|
|.equals|参照型(StringBuilderなど)の同値比較くをする場合に使う|
|.deepEquals|ネストした配列の同値比較を行う時に使う|


##  **アクセス修飾子**

### **protected**
- 同一パッケージ内もしくは、違うパッケージでも継承関係ならアクセスOKとなる

### **final**
- 再代入できない様にできる

```
以下のケースについては、参照型(list)をfinalで定義しているため
参照先のデータについては変更できてしまう

final int[] VALUE = {10, 20, 30}
VALUE = new int[] {10, 30, 50} --> 変更できない(参照先を変更しようとしてるため)
int[0] = 50 --> 変更できる(参照先のデータを変更しようとしてるため)


上記のケースが仮にStringだった場合は、変更できない(Stringは不変系)
なのでString＋finalで完全に変更できない値が作れる
```



## **データ型**
|整数 |    |    |
|----|----|----|
|byte|1byte||
|short|2byte||
|int|4byte|特別な理由がない場合はこれ使う|
|long|8byte||

備考 : </br>
- "_"で桁を区切って読み易くすることが出来る
- intの値をlongに格納すると暗黙的な型変換(拡大変換)で格納することができる
- intからbyteへの縮小変換については、"(byte)"を変数名の前につけて行う明示的変換でのみ可能


|浮動小数点 |    |    |
|----|----|----|
|floot|4byte||
|double|8byte|特別な理由がない限りはこれ使う|

> 備考 : </br>
> 浮動少数点は、以下のように表現されている</br>
> 12.5(10進数)</br>
> = 1100.1000(2進数) </br>
> = 1.1001000 * 2^3</br>
> 上記を以下の様に格納することで表現されている</br>
> [1(符号"-")] [10000010(指数 3 + 127)] [100100(仮数 1は固定なので省略)]</br>
> 欠点として指数部の値が大きい時に値が飛び幅が大きくなる</br>
> 例　12.5 * 10^10 ~ 12.6 * 10^10 よりも　12.5 * 10^100 ~ 12.6 * 10^100の飛び幅はでかい

|真偽 |    |    |
|----|----|----|
|boolean|1bit|デフォルト値 : false|

|文字 |    |    |
|----|----|----|
|char|2bit|デフォルト値 : \u0000(null)</br>文字列ではなく文字を格納するイメージ|

### **var**
- 型推論で自動的に型を設定してくれる
- メソッド内の変数としてのみ定義可能(フィールド宣言できない)
- 必ず初期値を設定する必要がある
- 型を明示的にする必要がない場合は積極的に使う</br>
  (もう既に別の場所で型が明示的に宣言されている変数の受け渡しなど)

### **null**
- オブジェクトへの参照を持たない状態の変数の事</br>
- アクセスしようとするとNullPointerExceptionが発動する</br>
- オブジェクトが存在しない場合を明示的に示したい場合や、</br>
  オブジェクトを破棄したい場合に、限定して使用する</br>
-  Optionalを併用して使うとより安全

### **配列**
- 生成は以下の様に行う。
```
int[] list = new int[5] 長さのみ指定パターン
int[] list = new int[]{1, 2, 3, 4, 5} 初期値を入れとくパターン
int list[] = {1, 2, 3} C言語の名残パターン

アクセスは以下
int[2]
-> 3が返される
```
- インデックスに要素を超える数を設定すると、ArrayIndexOutOfBoundsException例外が発生</br>
- new して作成していることからStringのようにクラスがある様に見えるが、</br>
  そうではなくあくまで言語に組み込まれた擬似的なクラス</br>
- 特殊な配列として**ジャグ配列**という2次元目の要素数が異なる配列も定義可能
```
var list = new int[3][];
list[0] = new int[2]
list[1] = new int[5]
list[2] = new int[6]
```

### **ラッパークラス**
- 基本型のデータを包んで(ラップして)オブジェクトとしての機能を与えるもの
- 基本型に比べて処理効率も悪くヌルポの可能性が出てくるため限られた場面でのみ使用する
```
Character c = Character.valueOf("Z");
Integer i = new Integer(16); 
  ->非推奨valueOfを使うべき(コンストラクターからだとキャッシュが作成されず常に新しく作られてしまうため)
```
- 文字列からの変換は以下(変換不可の場合はNumberFormatException例外が発生)
```
int x = Integer.parseInt("2");

文字列に変換
String y = x.toString()
```

### **String**
|メソッド|説明|
|----|----|
|strA.compareTo(strB)|文字の比較(unicode値がどれだけ離れているか) strA>strBの時正, strB>strAの時負, strA=strBの時0|
|str.isEmpty()|文字が空("")であるかどうか|
|str.isBlank()|空文字(" ","\t"など)が含まれるかどうか|
|str.strip()|空文字の削除(java11)|
|str.indexOf(str,[int])|検索,対象の文字列のIndexを返す(存在しない場合は-1),intは開始位置|
|str.contains(str,[int])|文字を含んでいるかどうか,intは開始位置|
|str.substring(int bigin, int end)|開始位置から終了位置までの文字列を部分的抜き出す|
|str.sprit(str,[int])|文字列を特定の文字で分割,intは回数制限|
|String.join(CharSequence sep, str)|文字列を結合(sepは区切り文字)|
|String.format(strA, strB)|strAで書式文字列(%d,%sとか)こみの文字列,strBで書式指定文字列に部分に埋め込まれる文字列|


### **オートボクシング(Autoboxing)**
- 基本型からラッパーオブジェクトに暗黙的に変換されることを**ボクシング(boxing)**
- ラッパーオブジェクトから基本型に暗黙的に変換されることを**アンボクシング(anboxing)**
- 上記を合わせて**オートボクシング(Autoboxing)**
```
ボクシング
Integer i = 108;

アンボクシング
int j = i;
```
<注意点>
- 以下の様なケースだとオートボクシングが頻繁に発生してオーバーヘッドが高まる
```
Long result = 10; -> 基本形のlongを使用したかったのにLong使ってる

for (long i = 1; i < 100; i++) {
  result += i; ->ここでオートボクシングが発生してしまう
}
```



## **組み込み**

### **StringBuilder**
- "+"で結合す結合すると結合元、結合先、結合されたものの３つ作成される(効率が良くない)</br>
  ->新しいjavaでは＋の際にStringuBuilderが呼ばれて同じの性能が出る
- こいつの場合はあらかじめ確保した領域で行なっている
- 似たものとしてStringBufferがあるがこちらは、String Builderの排他的制御版(遅い)
```
領域については以下の様に指定できる
var builder = new StringBuilder(1000) -> あらかじめサイズを決めておける
```

### **BigDecimal**
- 以下の様な小数点以下で起こる誤差を解消してくれるもの
- 誤差を生じさせないために、引数は文字で指定するように
```
Math.floor((0.1 + 0.7) * 10)
-> 0.7
内部的に0.1は２進数で表すと無限循環小数になっているため
7.999999の様になっており上記の様な結果が返ってきていしまう
```




## **用語集**

### **完全修飾名**
- クラスを識別する際に、「パッケージ＋クラス名」で識別する。</br>
- 以下のようなフルで書いた状態のこと</br>
  java.time.LocalDateTime</br>
- 上記の様な状態を解決するために、importする(名前解決という)</br>
- 名前解決後のクラス名だけの状態を単純名という

### **静的型付け**
- 変数を宣言する際に設定した型以外の値を代入することが出来ないこと
- 型をプログラマが明示的に設定する必要がある

### **動的型付け**
- 変数を宣言する際に型を明示的に設定しなくても予測して設定してくれること

### **基本型**
- 数値や文字そのものが入っている変数のこと</br>
  プリミティブ型と呼ばれる事もある(構造がシンプルで原始的)
  int, charなど

### **参照型**
- 数値や文字が格納されている場所を持っている変数のこと</br>
  list, objなど

### **データソース**
- DBに接続する際に必要な情報(ホスト名など)をまとめたもの</br>
- DNS(固有の識別名)で識別される

### **リテラル**
- 値を格納できる値、また、値の表現方法</br>
  例 2進数(0b0100),16進数(0xff),文字('')、文字列("")

### **型サレフィックス**
- 末尾につけてデータ型を指定できるもの</br>
  long: L,l </br>
  float: F,f </br>
  double: D,d</br>

### **インスタンス/オブジェクト**
- クラスをnewした物</br>
  クラス内のフィールドはコピーされ、メソッドはクラスでの定義を参照

### **フィールド**
- クラス内で用意されているデータの入れ物

### **クラスフィールド/クラスメソッド**
- オブジェクトを生成せずともクラスから直接呼び出せる(静的フィールド/静的メソッドとも言う)</br>
- 反対にオブジェクトの生成が必要なものを、**インスタンスフィールド/インスタンスメソッド**という

### **同一性/同値性**
- 同一性は値が同一のものかどうか、javaにおいては"=="で比較される(基本型はこれで比較しても値の比較が行われる)
- 同値性は値が同じ値かどうか、javaにおいては"equals"メソッドで比較する(参照型はこれを使えば値の比較が行われる)
```
例
String stringA = new StringBuilder("ABC").toString();
String stringB = new StringBuilder("ABC").toString();

stringA == stringB
-> false
上記については、stringAとstringBで別の番地のメモリに格納された
別物なのでfalse判定

stringA.equals(stringB)
-> true
この場合は値が同じかどうか(同値性)を見ているためtrue判定

```

### **順次/選択/繰り返し**
- 下記の処理を組み合わせて作成することを**構造化プログラミング**という</br>
  **順次(順接) :** 上から順に処理</br>
  **選択 :** 条件分岐など処理を分岐</br>
  **繰り返し :** 特定の処理を繰り返す </br>

### **ラベル(句)**
- switchぶんで用いられる、caseを表す"xxxx:"を指す

### **サロゲートペア**
- Unicodeの2byteでは表現しきれなくなってきた文字についてを、4byteで表現する様にした文字のこと


## Command Line 
- コンパイル時にディレクトリ配下にクラスファイルを生成する
```
javac ファイル名 -d 生成先フォルダ
```



# Eclipse

## **Shortcut**
|    |    |
|----|----|
|Ctr + Space|ソースの補完|

## **コマンドライン引数**
mainメソッドの引数argsとして受け取れる</br>
実行マークのプルダウン>実行の構成>引数タブ>プログラムの引数
